<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RF_SDK: nextlimit::rf_sdk::PB_Emitter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RF_SDK&#160;<span id="projectnumber">9.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacenextlimit.html">nextlimit</a>      </li>
      <li class="navelem"><a class="el" href="namespacenextlimit_1_1rf__sdk.html">rf_sdk</a>      </li>
      <li class="navelem"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">nextlimit::rf_sdk::PB_Emitter Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="nextlimit::rf_sdk::PB_Emitter" --><!-- doxytag: inherits="RFNodeType&lt; ::ParticleFluidEmitter3, nl::rf_sdk::Node_ExpRsc &gt;" -->
<p><code>#include &lt;<a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classnextlimit_1_1rf__sdk_1_1_r_f_node_type.html">nextlimit::rf_sdk::RFNodeType&lt; ::ParticleFluidEmitter3, nl::rf_sdk::Node_ExpRsc &gt;</a>.</p>

<p><a href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter_1_1iterator.html">iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3">ParticleAttributeType</a> { <br/>
&#160;&#160;<a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3a0b3487e8687392507c6368bed6018348">PARTICLE_ATTR_TYPE_DOUBLE</a>, 
<a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3a28e3912d64a3160a0ffb5c24f13745df">PARTICLE_ATTR_TYPE_FLOAT</a>, 
<a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3a8290ce2006407e5bca59c8124ebf2a87">PARTICLE_ATTR_TYPE_INT</a>, 
<a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3aa4eb16b8b851ba5a146a5a06c8b25b37">PARTICLE_ATTR_TYPE_CHAR</a>, 
<br/>
&#160;&#160;<a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3a5ad952844e27c4daa1aaad14b293267b">PARTICLE_ATTR_TYPE_BOOL</a>, 
<a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3a5b785be11f4280d2100d02333166ef70">PARTICLE_ATTR_TYPE_VECTOR</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a058a9cd1caa7ad502fcbc6b21bec9c76">DECLARE_STD_VECTOR_TYPES</a> (<a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter_1_1iterator.html">PB_Emitter::iterator</a>, SdkPB_EmitterIters)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations:</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a84f894da3390aba33b9e693ed5af7f29">getParticles</a> (std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> &gt; &amp;particles)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERFACE.  <a href="#a84f894da3390aba33b9e693ed5af7f29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ab9436189ded9b80d636fa3bfcaf81183">getFirstParticle</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad46445aa02fbfb4b2e51ed1a9c3fa96d">getParticle</a> (int particleId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ab0b58b8c4154451bf4e21f3a4104a311">removeParticle</a> (long particleId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a17d25d78d8477bb9115f84e314cc0506">addParticle</a> (const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;globalPos, const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;velocity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a2eafcc2d874aea2a7a076c19967891bc">getParticlesColliding</a> (std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> &gt; &amp;outParticles)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#afe0385623a41b093c619b104b526a855">sdkExport</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad8ab59e29a1cedb3e32492d9f9c4415b">createVoxelization</a> (const bool forceCreationDataStrt, const float voxelLength=0.0f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ae97bff2e5a12556e96551379447c1fcf">destroyVoxelization</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#af62ce0f3fd0f46e616462f729c82e473">testPositionForParticleInsertion</a> (const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;globalPos, float relaxFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a19a8b0d5935fe4a0c60c78f9f42f5374">removeAllParticles</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad17f4b6b791209a35d6523edefba0ae2">computeVorticity</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ab27f37920b60ea6d4feaa45b82ca3351">getSelectedVertices</a> (std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vertex.html">Vertex</a> &gt; &amp;sdkVertexs, int typeRef=REF_GLOBAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a990af2aaffd26a98407021ccdcefbcc3">getSelectedFaces</a> (std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_face.html">Face</a> &gt; &amp;sdkFaces)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a83eb9996f8c86f6db00818e33fdf14f4">setSelectedFaces</a> (const std::vector&lt; int &gt; &amp;idxs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a7640a24cd3f5e81d444ea6f59574bed1">setSelectedVertices</a> (const std::vector&lt; int &gt; &amp;idxs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter_1_1iterator.html">PB_Emitter::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a0a099442186e2f08406e3d9624ad30db">getIterator</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a29ae174c0ad21ea250dde8c66df9cdbc">getPartition</a> (ArrSdkPB_EmitterIters &amp;partitionOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a2f15522b48f9eb9d372dba3f43e619f0">getPartitionSet</a> (std::vector&lt; ArrSdkPB_Particles &gt; &amp;outPartition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const NL_UINT64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a4ec8052957faea8dd9780169cdeab077">getType</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a0af17f850c4933d978804b606992d133">getId</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a31a744c66b91971a641a9f30df3dd854">createParticlesAttribute</a> (const int &amp;id, const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3">ParticleAttributeType</a> &amp;type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a02e8728c3dcc61a4f8e1c20210788bbb">createParticlesAttribute</a> (const int &amp;id, const unsigned int &amp;dataSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a9f1de8281b1eb1551da5c99fe0b06807">destroyParticlesAttribute</a> (const int &amp;id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a97229fe569604b873a1dc602bde14930">queryParticlesAttribute</a> (const int &amp;id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#af4132c09e2b24699dcb58eead41087a5">getSelectedParticles</a> (const std::string &amp;group, std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> &gt; &amp;particles)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#af1ce571df9219e9abbdf7cb5a04dc235">getParticleSelectionGroups</a> (std::vector&lt; std::string &gt; &amp;groups)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ab4495fee452967587cf05d23d01340c7">getNumberOfParticles</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aadc7ed43367e15f04be01094bf08ed6c">addParticles</a> (const ArrSdkVectors &amp;positions, const ArrSdkVectors &amp;velocities, const NL_BOOL safe=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aa851f1d890c22a247e79993d644c8ca7">getEmitterType</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a9fb45451c908cd8313ab6560b9729ded">setEditionMode</a> (const bool enableEdition)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations (control points)</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#acc8b8d5ae2bb445caf7f0c2f88b97eb9">insertControlPoint</a> (const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;position, const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;handleInPosition, const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;handleOutPosition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aba9f073925653a8623183441008548f8">removeControlPoint</a> (const unsigned int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a32fa052daee0d0ece84e69bd16601092">removeControlPoints</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a26ed22cfeef00a1c7fd718f4c0a28189">removeAllControlPoints</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ac03335c15bd9904877a71f82d01c94f5">getNumberOfControlPoints</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a19a5fc5b69dc6fac65fa13e09c2bbbc3">setControlPointPosition</a> (const unsigned int index, const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a46ac0cd3e74b4a521dbaad650d9f2b56">setControlPointHandleInPosition</a> (const unsigned int index, const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aa8d5a070bd8c3453adee4a77319ca1de">setControlPointHandleOutPosition</a> (const unsigned int index, const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#abdce3fb8553031390b85ea7609a0edd7">setControlPointParameter</a> (const unsigned int index, const std::string &amp;name, const std::string &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ae3e958455edd7e4894802555f109c414">setControlPointParameter</a> (const unsigned int index, const std::string &amp;name, const int &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a94eeedf74d86ad71ce609524f46ada27">setControlPointParameter</a> (const unsigned int index, const std::string &amp;name, const int64_t &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a91a545ef6ad5b046803113b3c43184b0">setControlPointParameter</a> (const unsigned int index, const std::string &amp;name, const float &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#afbf41bc93f0b76d926663a488ec13bc9">setControlPointParameter</a> (const unsigned int index, const std::string &amp;name, const double &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a703b0ea698c44c8ea37a0c200aefe5d9">setControlPointParameter</a> (const unsigned int index, const std::string &amp;name, const nl::rf_sdk::Vector &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aef9350288b76594db5e1630fcf203e4c">setControlPointParameter</a> (const unsigned int index, const std::string &amp;name, const nl::rf_sdk::Color &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a00ff630c681739fd03d6a5cd75470c6a">getControlPointParameter</a> (const unsigned int index, const std::string &amp;name, bool &amp;ok) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacenextlimit_1_1rf__sdk_1_1sdk__type.html#a0ab44681dac24cdb6ba51c89752a3de4">sdk_type::SdkParamType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#acd8101350d0c792782b33f1558f757b4">getControlPointParameterType</a> (const std::string &amp;name, bool &amp;ok) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_curve.html">Curve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aba7afe8959fce39eb44e0bf5c98ef771">getControlPointParameterCurve</a> (const unsigned int index, const std::string &amp;name, bool &amp;ok) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a73550588fe993359943aeef038c0b13e">getControlPointAllParameterNames</a> (std::vector&lt; std::pair&lt; std::string, int &gt; &gt; &amp;parameterNames) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#adfd3967334d627064f1a7ac592dec646">getControlPointCurveName</a> (const int pointIndex, const std::string parameterName) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ac6019aa2c4a755a74d3592c4b357b593">evaluateSpline</a> (const unsigned int span, const float t, <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;result) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aedbdd5a5c7d860199a4314ed05f3ba36">EXPORT_PARTICLES_BIN</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a102e53c3d0fe510be3a2ee8bb32222bd">EXPORT_PARTICLES_PROXY</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#af5738f9e383516e6c98e5963f9e98466">EXPORT_PARTICLES_ASC</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aae52b47ba96f0b887c049cd8ca5f49c9">EXPORT_PARTICLES_PRT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#afd7a3c4403f1f4e0ad917fac4fe814c8">EXPORT_PARTICLES_PDC</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a912924e11ead0ff8ba0a8faf4cb268d3">EXPORT_PARTICLES_PD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a1ee9e7f3548dd8a6f55aadcd458a42f7">EXPORT_GRID_FOAM_FTC</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a12298d8a1479e4849d7f2d8ff8662cd3">EXPORT_GRID_FOAM_TEXTURE</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Helper methods</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacenextlimit_1_1rf__sdk_1_1sdk__type.html#ab04094ce5c4a005eb1bb6a784eb385bd">sdk_type::SdkType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a383a12c8ac6c9291343a5a29099af298">getSdkType</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aff1ec51c1b6230138f6fb3ecf452e0fb">getPartitionSetInt</a> (std::vector&lt; std::vector&lt; nl::rf_sdk::PB_Particle &gt; &gt; &amp;outParticles)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#adeb0609ba32f64c35ce56f2e834bab5b">getPartitionInt</a> (ArrSdkPB_EmitterIters &amp;partitionOut)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Life Cycle:</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#af84099c19f1e72645df1ba855d8a0eae">~PB_Emitter</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af84099c19f1e72645df1ba855d8a0eae"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00060">60</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad6d4221ea7c577f4b768c5f9adc931f3"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::ParticleAttributeType" ref="ad6d4221ea7c577f4b768c5f9adc931f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3">nextlimit::rf_sdk::PB_Emitter::ParticleAttributeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad6d4221ea7c577f4b768c5f9adc931f3a0b3487e8687392507c6368bed6018348"></a><!-- doxytag: member="PARTICLE_ATTR_TYPE_DOUBLE" ref="ad6d4221ea7c577f4b768c5f9adc931f3a0b3487e8687392507c6368bed6018348" args="" -->PARTICLE_ATTR_TYPE_DOUBLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad6d4221ea7c577f4b768c5f9adc931f3a28e3912d64a3160a0ffb5c24f13745df"></a><!-- doxytag: member="PARTICLE_ATTR_TYPE_FLOAT" ref="ad6d4221ea7c577f4b768c5f9adc931f3a28e3912d64a3160a0ffb5c24f13745df" args="" -->PARTICLE_ATTR_TYPE_FLOAT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad6d4221ea7c577f4b768c5f9adc931f3a8290ce2006407e5bca59c8124ebf2a87"></a><!-- doxytag: member="PARTICLE_ATTR_TYPE_INT" ref="ad6d4221ea7c577f4b768c5f9adc931f3a8290ce2006407e5bca59c8124ebf2a87" args="" -->PARTICLE_ATTR_TYPE_INT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad6d4221ea7c577f4b768c5f9adc931f3aa4eb16b8b851ba5a146a5a06c8b25b37"></a><!-- doxytag: member="PARTICLE_ATTR_TYPE_CHAR" ref="ad6d4221ea7c577f4b768c5f9adc931f3aa4eb16b8b851ba5a146a5a06c8b25b37" args="" -->PARTICLE_ATTR_TYPE_CHAR</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad6d4221ea7c577f4b768c5f9adc931f3a5ad952844e27c4daa1aaad14b293267b"></a><!-- doxytag: member="PARTICLE_ATTR_TYPE_BOOL" ref="ad6d4221ea7c577f4b768c5f9adc931f3a5ad952844e27c4daa1aaad14b293267b" args="" -->PARTICLE_ATTR_TYPE_BOOL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad6d4221ea7c577f4b768c5f9adc931f3a5b785be11f4280d2100d02333166ef70"></a><!-- doxytag: member="PARTICLE_ATTR_TYPE_VECTOR" ref="ad6d4221ea7c577f4b768c5f9adc931f3a5b785be11f4280d2100d02333166ef70" args="" -->PARTICLE_ATTR_TYPE_VECTOR</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00066">66</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af84099c19f1e72645df1ba855d8a0eae"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::~PB_Emitter" ref="af84099c19f1e72645df1ba855d8a0eae" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual nextlimit::rf_sdk::PB_Emitter::~PB_Emitter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00120">120</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a17d25d78d8477bb9115f84e314cc0506"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::addParticle" ref="a17d25d78d8477bb9115f84e314cc0506" args="(const Vector &amp;globalPos, const Vector &amp;velocity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> nextlimit::rf_sdk::PB_Emitter::addParticle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>addParticle: Add a Particle to the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">globalPos</td><td>/ New Particle 's global position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">velocity</td><td>/ New Particle 's velocity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadc7ed43367e15f04be01094bf08ed6c"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::addParticles" ref="aadc7ed43367e15f04be01094bf08ed6c" args="(const ArrSdkVectors &amp;positions, const ArrSdkVectors &amp;velocities, const NL_BOOL safe=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::addParticles </td>
          <td>(</td>
          <td class="paramtype">const ArrSdkVectors &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArrSdkVectors &amp;&#160;</td>
          <td class="paramname"><em>velocities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NL_BOOL&#160;</td>
          <td class="paramname"><em>safe</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>addParticles</p>
<p>Add particles to the emitter using a list of positions and velocities. By default is done in a safe manner so particles won't be added when the position is not valid, i.e. adding a particle at that position will make the fluid instable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">[ArrSdkVector]</td><td>positions / List of positions. </td></tr>
    <tr><td class="paramname">[ArrSdkVector]</td><td>velocities / List of velocities. </td></tr>
    <tr><td class="paramname">[ArrSdkVector]</td><td>safe / true to add particles in a safe manner, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad17f4b6b791209a35d6523edefba0ae2"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::computeVorticity" ref="ad17f4b6b791209a35d6523edefba0ae2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::computeVorticity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>computeVorticity: Compute the vorticity attribute for all the particles in THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> </p>

</div>
</div>
<a class="anchor" id="a31a744c66b91971a641a9f30df3dd854"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::createParticlesAttribute" ref="a31a744c66b91971a641a9f30df3dd854" args="(const int &amp;id, const ParticleAttributeType &amp;type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::createParticlesAttribute </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#ad6d4221ea7c577f4b768c5f9adc931f3">ParticleAttributeType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>createParticlesAttribute:</p>
<p>Creates an attribute for all the particles in this emitter. Existent and new particles will have the new attribute.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>/ Unique identification for the attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>/ Type of the attribute, valid values are : PARTICLE_ATTR_TYPE_BOOL PARTICLE_ATTR_TYPE_CHAR PARTICLE_ATTR_TYPE_INT PARTICLE_ATTR_TYPE_FLOAT PARTICLE_ATTR_TYPE_DOUBLE PARTICLE_ATTR_TYPE_VECTOR</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: True if the attribute was created, False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a02e8728c3dcc61a4f8e1c20210788bbb"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::createParticlesAttribute" ref="a02e8728c3dcc61a4f8e1c20210788bbb" args="(const int &amp;id, const unsigned int &amp;dataSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::createParticlesAttribute </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>createParticlesAttribute:</p>
<p>Creates an attribute for all the particles in this emitter. Existent and new particles will have the new attribute. The size of the data is specified instead of the type so this function allows you to create chunks of data per particle.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>/ Unique identification for the attribute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>/ Size of data in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: True if the attribute was created, False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8ab59e29a1cedb3e32492d9f9c4415b"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::createVoxelization" ref="ad8ab59e29a1cedb3e32492d9f9c4415b" args="(const bool forceCreationDataStrt, const float voxelLength=0.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::createVoxelization </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>forceCreationDataStrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>voxelLength</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>createVoxelization: Create the internal data structures that RealFlow uses for speed up the searching of the nearest neighbors. Please note that these data structures are only created automatically by RealFlow for "Liquid" type particles and particle solver plug-ins during the simulation process. If your particle type doesn't match those and you want to find neighbors you must call this function explicitly. The same is applicable if your fluid is of "Liquid" type but you are running the script off the simulation loop.</p>
<p>NOTE: if you remove particles from an <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> where you have created the internal data structures you have to re-create the data structures again because they become invalid. </p>

</div>
</div>
<a class="anchor" id="a058a9cd1caa7ad502fcbc6b21bec9c76"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::DECLARE_STD_VECTOR_TYPES" ref="a058a9cd1caa7ad502fcbc6b21bec9c76" args="(PB_Emitter::iterator, SdkPB_EmitterIters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nextlimit::rf_sdk::PB_Emitter::DECLARE_STD_VECTOR_TYPES </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter_1_1iterator.html">PB_Emitter::iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SdkPB_EmitterIters&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f1de8281b1eb1551da5c99fe0b06807"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::destroyParticlesAttribute" ref="a9f1de8281b1eb1551da5c99fe0b06807" args="(const int &amp;id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::destroyParticlesAttribute </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>destroyParticlesAttribute:</p>
<p>Destroys an attribute for all the particles in this emitter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>/ Identification for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: True if the attribute was destroyed, False otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ae97bff2e5a12556e96551379447c1fcf"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::destroyVoxelization" ref="ae97bff2e5a12556e96551379447c1fcf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::destroyVoxelization </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>destroyVoxelization: Destroys the current voxelization freeing all the related resources. See "createVoxelization" to learn mode about RealFlow voxelization. </p>

</div>
</div>
<a class="anchor" id="ac6019aa2c4a755a74d3592c4b357b593"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::evaluateSpline" ref="ac6019aa2c4a755a74d3592c4b357b593" args="(const unsigned int span, const float t, Vector &amp;result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::evaluateSpline </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>span</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>evaluateSpline:</p>
<p>If the emitter is of <a class="el" href="classnextlimit_1_1rf__sdk_1_1_spline.html">Spline</a> type, returns the point of the spline given by the span and the parameter t. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">span</td><td>/ The section of the spline to be evaluated. Must be less than the number of control points of the spline. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>/ Parameter between 0 and 1 to determine where the spline is evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>/ The position of the spline for the given parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the span is out of range or this is not a spline emitter. </dd></dl>

</div>
</div>
<a class="anchor" id="a73550588fe993359943aeef038c0b13e"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getControlPointAllParameterNames" ref="a73550588fe993359943aeef038c0b13e" args="(std::vector&lt; std::pair&lt; std::string, int &gt; &gt; &amp;parameterNames) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::getControlPointAllParameterNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameterNames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getControlPointAllParameterNames:</p>
<p>Gets a list of Tuples &lt; Parameter name, Parameter type &gt;</p>
<ul>
<li>Parameter names and types existing for the control point</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">parameterNames</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Tuples &lt; Parameter name, Parameter type &gt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="adfd3967334d627064f1a7ac592dec646"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getControlPointCurveName" ref="adfd3967334d627064f1a7ac592dec646" args="(const int pointIndex, const std::string parameterName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nextlimit::rf_sdk::PB_Emitter::getControlPointCurveName </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pointIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>parameterName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getControlPointCurveName:</p>
<p>Deprecated, now is possible to access the curve of a control point using the control point index. </p>

</div>
</div>
<a class="anchor" id="a00ff630c681739fd03d6a5cd75470c6a"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getControlPointParameter" ref="a00ff630c681739fd03d6a5cd75470c6a" args="(const unsigned int index, const std::string &amp;name, bool &amp;ok) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T nextlimit::rf_sdk::PB_Emitter::getControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getControlPointParameter:</p>
<p>Get the control point value for the parameter. Please read "setControlPointParameter" description to know more about this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ok</td><td>/ False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: The control point parameter's value. </dd></dl>

</div>
</div>
<a class="anchor" id="aba7afe8959fce39eb44e0bf5c98ef771"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getControlPointParameterCurve" ref="aba7afe8959fce39eb44e0bf5c98ef771" args="(const unsigned int index, const std::string &amp;name, bool &amp;ok) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_curve.html">Curve</a> nextlimit::rf_sdk::PB_Emitter::getControlPointParameterCurve </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getControlPointParameterCurve:</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ok</td><td>/ False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: The control point parameter's curve </dd></dl>

</div>
</div>
<a class="anchor" id="acd8101350d0c792782b33f1558f757b4"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getControlPointParameterType" ref="acd8101350d0c792782b33f1558f757b4" args="(const std::string &amp;name, bool &amp;ok) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacenextlimit_1_1rf__sdk_1_1sdk__type.html#a0ab44681dac24cdb6ba51c89752a3de4">sdk_type::SdkParamType</a> nextlimit::rf_sdk::PB_Emitter::getControlPointParameterType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getControlPointParameterType:</p>
<p>Get the control point parameter's type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ Control point parameter's name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ok</td><td>/ False if the parameter can't be changed, reasons could be:<ul>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: The parameter type, values in Param_Type [ TYPE_FLOAT TYPE_DOUBLE TYPE_LIST TYPE_INT TYPE_BOOL TYPE_EDIT TYPE_CBUTTON TYPE_BUTTON TYPE_BROWSE TYPE_VECTOR TYPE_COLOR ] </dd></dl>

</div>
</div>
<a class="anchor" id="aa851f1d890c22a247e79993d644c8ca7"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getEmitterType" ref="aa851f1d890c22a247e79993d644c8ca7" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nextlimit::rf_sdk::PB_Emitter::getEmitterType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getEmitterType:</p>
<p>Returns the name of the type of the emitter. For example: "Circle"..</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>:The type of the emitter as a string </dd></dl>

</div>
</div>
<a class="anchor" id="ab9436189ded9b80d636fa3bfcaf81183"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getFirstParticle" ref="ab9436189ded9b80d636fa3bfcaf81183" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> nextlimit::rf_sdk::PB_Emitter::getFirstParticle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getFirstParticle: Gets the emitter's first particle. If THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> has no particles then a Null Particle is returned This member function is very useful when we want to iterate the particles in the emitter. Just get the first particle and then iterate the particles by using the "getNextParticle()" member function in the "Particle" class. This approach is preferred to that one where the whole list of particles is got at once and then we iterate them. In that case a whole copy of the list of particles must be obtained. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>: <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's first Particle if found Null Particle if THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> has no particles </dd></dl>

</div>
</div>
<a class="anchor" id="a0af17f850c4933d978804b606992d133"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getId" ref="a0af17f850c4933d978804b606992d133" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int nextlimit::rf_sdk::PB_Emitter::getId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getId: Gets the id of this emitter </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the id of this emitter </dd></dl>

</div>
</div>
<a class="anchor" id="a0a099442186e2f08406e3d9624ad30db"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getIterator" ref="a0a099442186e2f08406e3d9624ad30db" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter_1_1iterator.html">PB_Emitter::iterator</a> nextlimit::rf_sdk::PB_Emitter::getIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getFirstParticle: Gets an Iterator over all the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's Particles. In the same order that you would get using the method firstParticle and traversing the list of particles calling repeatedly getNextParticle. This approach is preferred to that one where the whole list of particles is got at once and then we iterate them. In that case a whole copy of the list of particles must be obtained. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>: <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's Particles Iterator </dd></dl>

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00270">270</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

<p>References <a class="el" href="rfbaseobj_8h_source.html#l00438">nextlimit::rf_sdk::RFNativeBaseObj&lt; T &gt;::getNativeObj()</a>, and <a class="el" href="rfbaseobj_8h_source.html#l00423">nextlimit::rf_sdk::RFNativeBaseObj&lt; T &gt;::isNull()</a>.</p>

</div>
</div>
<a class="anchor" id="ac03335c15bd9904877a71f82d01c94f5"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getNumberOfControlPoints" ref="ac03335c15bd9904877a71f82d01c94f5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nextlimit::rf_sdk::PB_Emitter::getNumberOfControlPoints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getNumberOfControlPoints: Returns the number of control points of the DSpline emitter.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>:The number of control points. 0 if emitter is not of DSpline type. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4495fee452967587cf05d23d01340c7"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getNumberOfParticles" ref="ab4495fee452967587cf05d23d01340c7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int nextlimit::rf_sdk::PB_Emitter::getNumberOfParticles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getNumberOfParticles:</p>
<p>returns the number of particles of this emitter</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>: the number of particles of the emitter </dd></dl>

</div>
</div>
<a class="anchor" id="ad46445aa02fbfb4b2e51ed1a9c3fa96d"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getParticle" ref="ad46445aa02fbfb4b2e51ed1a9c3fa96d" args="(int particleId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> nextlimit::rf_sdk::PB_Emitter::getParticle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>particleId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getParticle: Get Particle by Id from THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>/ Particle 's Id </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: Particle if found Null Particle if there is no Particle with such Id </dd></dl>

</div>
</div>
<a class="anchor" id="a84f894da3390aba33b9e693ed5af7f29"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getParticles" ref="a84f894da3390aba33b9e693ed5af7f29" args="(std::vector&lt; PB_Particle &gt; &amp;particles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getParticles </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>particles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>INTERFACE. </p>
<p>getParticles: Get <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's list of particles. You might want to iterate the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's particles using the "getFirstParticle" and the particle's function "getNextParticle" instead of using this function if the number of particles is really big. In that case if you use this function you will obtain a copy of all the particles which means more memory resources needed. See the "getFirstParticle" function to learn more about how to get and iterate particles. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Particles</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Particles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2eafcc2d874aea2a7a076c19967891bc"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getParticlesColliding" ref="a2eafcc2d874aea2a7a076c19967891bc" args="(std::vector&lt; PB_Particle &gt; &amp;outParticles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getParticlesColliding </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outParticles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getParticlesColliding: Get the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's list of Particles that are colliding at the moment this function is called. In the simulation pipeline there is a moment where the collision is detected, at that moment the flag of collision for every particle colliding is set and is cleared at the beginning of the next simulation cycle. Because of that reason we can guarantee that there is always a valid list of particles at the "Simulation Step End" event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Particles</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Particles colliding </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1ce571df9219e9abbdf7cb5a04dc235"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getParticleSelectionGroups" ref="af1ce571df9219e9abbdf7cb5a04dc235" args="(std::vector&lt; std::string &gt; &amp;groups)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getParticleSelectionGroups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getParticleSelectionGroups: Get <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's list of particle selection group names.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">groups</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of names </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29ae174c0ad21ea250dde8c66df9cdbc"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getPartition" ref="a29ae174c0ad21ea250dde8c66df9cdbc" args="(ArrSdkPB_EmitterIters &amp;partitionOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getPartition </td>
          <td>(</td>
          <td class="paramtype">ArrSdkPB_EmitterIters &amp;&#160;</td>
          <td class="paramname"><em>partitionOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getPartition: Obtains a partition of all the particles of THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> used to make parallel calculations. Each partition is represented by an <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's Particles Iterator, by which you can access sequentially to all the particles that belong to the same partition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">partition</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter_1_1iterator.html">PB_Emitter::iterator</a> each Iterator representing a partition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adeb0609ba32f64c35ce56f2e834bab5b"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getPartitionInt" ref="adeb0609ba32f64c35ce56f2e834bab5b" args="(ArrSdkPB_EmitterIters &amp;partitionOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getPartitionInt </td>
          <td>(</td>
          <td class="paramtype">ArrSdkPB_EmitterIters &amp;&#160;</td>
          <td class="paramname"><em>partitionOut</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f15522b48f9eb9d372dba3f43e619f0"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getPartitionSet" ref="a2f15522b48f9eb9d372dba3f43e619f0" args="(std::vector&lt; ArrSdkPB_Particles &gt; &amp;outPartition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getPartitionSet </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ArrSdkPB_Particles &gt; &amp;&#160;</td>
          <td class="paramname"><em>outPartition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getPartition: Obtains a partition of all the particles of THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> used to make parallel calculations. Each partition is represented by <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Particles.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">partition</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Particles, each <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Particles representing a partition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff1ec51c1b6230138f6fb3ecf452e0fb"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getPartitionSetInt" ref="aff1ec51c1b6230138f6fb3ecf452e0fb" args="(std::vector&lt; std::vector&lt; nl::rf_sdk::PB_Particle &gt; &gt; &amp;outParticles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getPartitionSetInt </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; nl::rf_sdk::PB_Particle &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>outParticles</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a383a12c8ac6c9291343a5a29099af298"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getSdkType" ref="a383a12c8ac6c9291343a5a29099af298" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacenextlimit_1_1rf__sdk_1_1sdk__type.html#ab04094ce5c4a005eb1bb6a784eb385bd">sdk_type::SdkType</a> nextlimit::rf_sdk::PB_Emitter::getSdkType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00768">768</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

<p>References <a class="el" href="rfbaseobj_8h_source.html#l00051">nextlimit::rf_sdk::sdk_type::PB_EMITTER_TYPE</a>.</p>

</div>
</div>
<a class="anchor" id="a990af2aaffd26a98407021ccdcefbcc3"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getSelectedFaces" ref="a990af2aaffd26a98407021ccdcefbcc3" args="(std::vector&lt; Face &gt; &amp;sdkFaces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getSelectedFaces </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_face.html">Face</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sdkFaces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getSelectedFaces: Gets the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's selected Faces.</p>
<p>IMPORTANT: This method only works for "Object Emitters"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sdkFaces</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4132c09e2b24699dcb58eead41087a5"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getSelectedParticles" ref="af4132c09e2b24699dcb58eead41087a5" args="(const std::string &amp;group, std::vector&lt; PB_Particle &gt; &amp;particles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getSelectedParticles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___particle.html">PB_Particle</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>particles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getSelectedParticles: Get <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's list of user selected particles for the specified group.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>/ Name of the selection group </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">particles</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Particles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab27f37920b60ea6d4feaa45b82ca3351"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getSelectedVertices" ref="ab27f37920b60ea6d4feaa45b82ca3351" args="(std::vector&lt; Vertex &gt; &amp;sdkVertexs, int typeRef=REF_GLOBAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::getSelectedVertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sdkVertexs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeRef</em> = <code>REF_GLOBAL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getSelectedVertices: Gets the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's selected Vertexes.</p>
<p>IMPORTANT: This method only works for "Object Emitters"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typeRef</td><td>/ Coordinates reference used; #Default value = RF_LOCAL typeRef 's values in [ REF_GLOBAL, RF_LOCAL ] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sdkVertexs</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Vertexes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ec8052957faea8dd9780169cdeab077"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::getType" ref="a4ec8052957faea8dd9780169cdeab077" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const NL_UINT64 nextlimit::rf_sdk::PB_Emitter::getType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>getType: Gets the type of this Realflow <a class="el" href="classnextlimit_1_1rf__sdk_1_1_node.html">Node</a> <a class="el" href="classnextlimit_1_1rf__sdk_1_1_object.html">Object</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the type of this RealFlow <a class="el" href="classnextlimit_1_1rf__sdk_1_1_object.html">Object</a> </dd></dl>

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00303">303</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

<p>References <a class="el" href="namespacenextlimit_1_1rf__sdk_1_1node__type.html#a666191644081cf70864dda3f9600f10f">nextlimit::rf_sdk::node_type::TYPE_PB_EMITTER</a>.</p>

</div>
</div>
<a class="anchor" id="acc8b8d5ae2bb445caf7f0c2f88b97eb9"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::insertControlPoint" ref="acc8b8d5ae2bb445caf7f0c2f88b97eb9" args="(const Vector &amp;position, const Vector &amp;handleInPosition, const Vector &amp;handleOutPosition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::insertControlPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>handleInPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>handleOutPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insertControlPoint: Inserts a new control point for the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_spline.html">Spline</a> emitter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>/ The position of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handleInPosition</td><td>/ The position of the in handle of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handleOutPosition</td><td>/ The position of the out handle of the control point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="a97229fe569604b873a1dc602bde14930"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::queryParticlesAttribute" ref="a97229fe569604b873a1dc602bde14930" args="(const int &amp;id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::queryParticlesAttribute </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>queryParticlesAttribute:</p>
<p>Returns True if the attribute exists in the emitter False otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>/ Identification for the attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: True if the attribute exists, False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a26ed22cfeef00a1c7fd718f4c0a28189"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::removeAllControlPoints" ref="a26ed22cfeef00a1c7fd718f4c0a28189" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::removeAllControlPoints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeAllControlPoints: Removes all the DSpline emitter control points.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="a19a8b0d5935fe4a0c60c78f9f42f5374"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::removeAllParticles" ref="a19a8b0d5935fe4a0c60c78f9f42f5374" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::removeAllParticles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeAllParticles: Remove all <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> 's Particles </p>

</div>
</div>
<a class="anchor" id="aba9f073925653a8623183441008548f8"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::removeControlPoint" ref="aba9f073925653a8623183441008548f8" args="(const unsigned int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::removeControlPoint </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeControlPoint: Removes the current control point for the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_spline.html">Spline</a> emitter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the index of the control point is not valid or if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="a32fa052daee0d0ece84e69bd16601092"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::removeControlPoints" ref="a32fa052daee0d0ece84e69bd16601092" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::removeControlPoints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeControlPoints: Deprecated, use removeAllControlPoints instead.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0b58b8c4154451bf4e21f3a4104a311"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::removeParticle" ref="ab0b58b8c4154451bf4e21f3a4104a311" args="(long particleId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::removeParticle </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>particleId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removeParticle: Delete a Particle from THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>/ Particle 's Id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe0385623a41b093c619b104b526a855"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::sdkExport" ref="afe0385623a41b093c619b104b526a855" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::sdkExport </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>sdkExport: Write out all the resources that are active in the export central menus. </p>

</div>
</div>
<a class="anchor" id="a46ac0cd3e74b4a521dbaad650d9f2b56"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointHandleInPosition" ref="a46ac0cd3e74b4a521dbaad650d9f2b56" args="(const unsigned int index, const Vector &amp;position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointHandleInPosition </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointHandleInPosition: Set the position of the in handle of the control point.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>/ The new position of the in handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the index of the control point is not valid or if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8d5a070bd8c3453adee4a77319ca1de"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointHandleOutPosition" ref="aa8d5a070bd8c3453adee4a77319ca1de" args="(const unsigned int index, const Vector &amp;position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointHandleOutPosition </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointHandleOutPosition: Set the position of the out handle of the control point.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>/ The new position of the out handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the index of the control point is not valid or if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3e958455edd7e4894802555f109c414"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointParameter" ref="ae3e958455edd7e4894802555f109c414" args="(const unsigned int index, const std::string &amp;name, const int &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointParameter: Set value for the parameter of a control point. The parameter name is the one that can be seen in the user interface. It is not case sensitive. The value can be any type that is accepted for the parameters in the user interface. Care must be taken when using this function about the type of the values and the parameter names, a hard type and name check is done reporting the corresponding errors to the user in any case</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>/ The control point parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abdce3fb8553031390b85ea7609a0edd7"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointParameter" ref="abdce3fb8553031390b85ea7609a0edd7" args="(const unsigned int index, const std::string &amp;name, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointParameter: Set value for the parameter of a control point. The parameter name is the one that can be seen in the user interface. It is not case sensitive. The value can be any type that is accepted for the parameters in the user interface. Care must be taken when using this function about the type of the values and the parameter names, a hard type and name check is done reporting the corresponding errors to the user in any case</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>/ The control point parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a91a545ef6ad5b046803113b3c43184b0"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointParameter" ref="a91a545ef6ad5b046803113b3c43184b0" args="(const unsigned int index, const std::string &amp;name, const float &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointParameter: Set value for the parameter of a control point. The parameter name is the one that can be seen in the user interface. It is not case sensitive. The value can be any type that is accepted for the parameters in the user interface. Care must be taken when using this function about the type of the values and the parameter names, a hard type and name check is done reporting the corresponding errors to the user in any case</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>/ The control point parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a703b0ea698c44c8ea37a0c200aefe5d9"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointParameter" ref="a703b0ea698c44c8ea37a0c200aefe5d9" args="(const unsigned int index, const std::string &amp;name, const nl::rf_sdk::Vector &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nl::rf_sdk::Vector &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointParameter: Set value for the parameter of a control point. The parameter name is the one that can be seen in the user interface. It is not case sensitive. The value can be any type that is accepted for the parameters in the user interface. Care must be taken when using this function about the type of the values and the parameter names, a hard type and name check is done reporting the corresponding errors to the user in any case</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>/ The control point parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a94eeedf74d86ad71ce609524f46ada27"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointParameter" ref="a94eeedf74d86ad71ce609524f46ada27" args="(const unsigned int index, const std::string &amp;name, const int64_t &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointParameter: Set value for the parameter of a control point. The parameter name is the one that can be seen in the user interface. It is not case sensitive. The value can be any type that is accepted for the parameters in the user interface. Care must be taken when using this function about the type of the values and the parameter names, a hard type and name check is done reporting the corresponding errors to the user in any case</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>/ The control point parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aef9350288b76594db5e1630fcf203e4c"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointParameter" ref="aef9350288b76594db5e1630fcf203e4c" args="(const unsigned int index, const std::string &amp;name, const nl::rf_sdk::Color &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nl::rf_sdk::Color &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointParameter: Set value for the parameter of a control point. The parameter name is the one that can be seen in the user interface. It is not case sensitive. The value can be any type that is accepted for the parameters in the user interface. Care must be taken when using this function about the type of the values and the parameter names, a hard type and name check is done reporting the corresponding errors to the user in any case</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>/ The control point parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afbf41bc93f0b76d926663a488ec13bc9"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointParameter" ref="afbf41bc93f0b76d926663a488ec13bc9" args="(const unsigned int index, const std::string &amp;name, const double &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointParameter </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointParameter: Set value for the parameter of a control point. The parameter name is the one that can be seen in the user interface. It is not case sensitive. The value can be any type that is accepted for the parameters in the user interface. Care must be taken when using this function about the type of the values and the parameter names, a hard type and name check is done reporting the corresponding errors to the user in any case</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>/ The control point parameter name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>/ The control point parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the parameter can't be changed, reasons could be:<ul>
<li>The index of the control point is not valid.</li>
<li>The type of the emitter is not the ESpline.</li>
<li>The parameter does not exist.</li>
<li>The parameter type is not the right one. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a19a5fc5b69dc6fac65fa13e09c2bbbc3"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setControlPointPosition" ref="a19a5fc5b69dc6fac65fa13e09c2bbbc3" args="(const unsigned int index, const Vector &amp;position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setControlPointPosition </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setControlPointPosition:</p>
<p>Set the position of a control point.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>/ The index of the control point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>/ The new position of the control point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: False if the index of the control point is not valid or if the type of the emitter is not the ESpline. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fb45451c908cd8313ab6560b9729ded"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setEditionMode" ref="a9fb45451c908cd8313ab6560b9729ded" args="(const bool enableEdition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::setEditionMode </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enableEdition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setEditionMode: Changes the state of the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_spline.html">Spline</a> emitter edition mode. It is the same effect as when clicking on the "Edit" button.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enableEdition</td><td>/ True to activate edition mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>:True if the emitter is a <a class="el" href="classnextlimit_1_1rf__sdk_1_1_spline.html">Spline</a> emitter. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a83eb9996f8c86f6db00818e33fdf14f4"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setSelectedFaces" ref="a83eb9996f8c86f6db00818e33fdf14f4" args="(const std::vector&lt; int &gt; &amp;idxs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::setSelectedFaces </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setSelectedFaces: Selects Faces of THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> by index</p>
<p>IMPORTANT: This method only works for "Object Emitters"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of <a class="el" href="classnextlimit_1_1rf__sdk_1_1_face.html">Face</a> 's indexes to be selected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7640a24cd3f5e81d444ea6f59574bed1"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::setSelectedVertices" ref="a7640a24cd3f5e81d444ea6f59574bed1" args="(const std::vector&lt; int &gt; &amp;idxs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nextlimit::rf_sdk::PB_Emitter::setSelectedVertices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>idxs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>setSelectedVertices: Selects Vertexes of THIS <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> by index</p>
<p>IMPORTANT: This method only works for "Object Emitters"</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idxs</td><td>/ <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> of Vertexes 's indexes to be selected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af62ce0f3fd0f46e616462f729c82e473"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::testPositionForParticleInsertion" ref="af62ce0f3fd0f46e616462f729c82e473" args="(const Vector &amp;globalPos, float relaxFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nextlimit::rf_sdk::PB_Emitter::testPositionForParticleInsertion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnextlimit_1_1rf__sdk_1_1_vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>globalPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>relaxFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>testPositionForParticleInsertion: Add a Particle to the <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html">PB_Emitter</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">globalPos</td><td>/ Position to test in global coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relaxFactor</td><td>/ Relaxation factor to alleviate the testing condition :<ul>
<li>relaxFactor &lt; 0 ; relaxFactor is ignored</li>
<li>relaxFactor == 0.0 means no relaxation at all</li>
<li>relaxFactor &gt; 0 will relax the condition gradually </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool / True if it is safe to insert the particle, False otherwise. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a1ee9e7f3548dd8a6f55aadcd458a42f7"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_GRID_FOAM_FTC" ref="a1ee9e7f3548dd8a6f55aadcd458a42f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a1ee9e7f3548dd8a6f55aadcd458a42f7">nextlimit::rf_sdk::PB_Emitter::EXPORT_GRID_FOAM_FTC</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00084">84</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<a class="anchor" id="a12298d8a1479e4849d7f2d8ff8662cd3"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_GRID_FOAM_TEXTURE" ref="a12298d8a1479e4849d7f2d8ff8662cd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a12298d8a1479e4849d7f2d8ff8662cd3">nextlimit::rf_sdk::PB_Emitter::EXPORT_GRID_FOAM_TEXTURE</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00085">85</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<a class="anchor" id="af5738f9e383516e6c98e5963f9e98466"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_ASC" ref="af5738f9e383516e6c98e5963f9e98466" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#af5738f9e383516e6c98e5963f9e98466">nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_ASC</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00080">80</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<a class="anchor" id="aedbdd5a5c7d860199a4314ed05f3ba36"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_BIN" ref="aedbdd5a5c7d860199a4314ed05f3ba36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aedbdd5a5c7d860199a4314ed05f3ba36">nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_BIN</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00078">78</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<a class="anchor" id="a912924e11ead0ff8ba0a8faf4cb268d3"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PD" ref="a912924e11ead0ff8ba0a8faf4cb268d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a912924e11ead0ff8ba0a8faf4cb268d3">nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PD</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00083">83</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<a class="anchor" id="afd7a3c4403f1f4e0ad917fac4fe814c8"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PDC" ref="afd7a3c4403f1f4e0ad917fac4fe814c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#afd7a3c4403f1f4e0ad917fac4fe814c8">nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PDC</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00082">82</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<a class="anchor" id="a102e53c3d0fe510be3a2ee8bb32222bd"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PROXY" ref="a102e53c3d0fe510be3a2ee8bb32222bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#a102e53c3d0fe510be3a2ee8bb32222bd">nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PROXY</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00079">79</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<a class="anchor" id="aae52b47ba96f0b887c049cd8ca5f49c9"></a><!-- doxytag: member="nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PRT" ref="aae52b47ba96f0b887c049cd8ca5f49c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classnextlimit_1_1rf__sdk_1_1_p_b___emitter.html#aae52b47ba96f0b887c049cd8ca5f49c9">nextlimit::rf_sdk::PB_Emitter::EXPORT_PARTICLES_PRT</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pb__emitter_8h_source.html#l00081">81</a> of file <a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>E:/Projects/NextLimit/RealFlow/RFSdk/include/rf_sdk/sdk/<a class="el" href="pb__emitter_8h_source.html">pb_emitter.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Jul 24 2015 14:00:01 for RF_SDK by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
